# ABM Agent-based Modelling and Sound Change - Manual to the current version of the ABM



There is a number of R libraries you need, see at the top of Rcmd/loadLibraries.R.

Start from ABMmain.R, where you have some comments.

In general, you run a set of (related) simulations by going into a (new) folder and use it as a root log directory. This contains:
- simulation register
- several simulation directories

The simulation reg is a list of parameter lists, one per simulation.
A typical paramater list is the one in data/params.R. You can start from there and modify according to your needs.
The simulation reg is created by createSimulationRegister() and managed by other commands, you don't touch it directly (see below).

Each simulation dir is created with a name generated by generateSimulationName(), it has the form 'ABM<date><time>' (you can change the prefix if you want).
A simulation is inserted in the register with registerSimulation(). 
At sim start the field params$completed is set to FALSE. Once the sim has terminated, this is set to completed by the command setCompleted(). In this way if a simulation crashes you can select it by looking for not completed (see below), or just use the cmd purgeNotCompleted(rootLogDir) to eliminate both the sim dir and its entry in register.

After finishing one or more sims, your rootLogDir looks like:
ABM20181017115249  ABM20181017142138  ABM20181019105332
ABM20181017121743  ABM20181017201605  simulations_register.rds

Preparing data for a simulation:

A simulation requires a params list and a dataframe (actually a data.table). The columns are:
P1, P2, ... : acoustic features
initial: initial labels
label: current label (usually == initial)
speaker: number or name
group: must be there, if only one group, set it to 'dummy' or whatever
word: word labels

Each sim dir looks like this:
input.rds intLog.rds params.yaml pop.0.rds  pop.1.rds pop.2.rds ....

if you run in params$runMode == "single", while if you ran as "multiple" you have a dir level in between that looks like:
1/ 2/ 3/ 4/ ...
how many independent runs you set in params$multipleABMRuns.
Let's see each file in detail.

- params.yaml is the saved params list. It's in yaml format, so you can directly open it as text and read it conveniently. All other files are stored as rds, so you need readRDS(). 

- input.rds is a copy of the input file, as you can start with an existing dataframe and tweak (e.g. remove speakers etc). In this way you preserve the exact input.

- pop.<NUMBER>.rds are as many memory snapshots as params$nrOfSimulations (a bad name). These are data.tables that report the state of all agents. The columns are:
"P1" "P2" ... "word" "label" "initial" "valid" "nrOfTimesHeard" "producerID"    "timeStamp" "agentID" "speaker" "group" "equivalence" "condition"

most of them are the same as in input. Each speaker gets an agentID from the start. producerID records who was the agent that produced the saved token. "condition" is a (bad) name for the snapshot index, i.e. pop.0.rds is the memory at start, that is the same as the input, so condition == 0, then pop.1.rds is the first snapshot and condition == 1, etc.
"valid" is very important: if FALSE you have to ignore the row. It is used in agents' memories to represent free space.

- intLog.rds is the interaction log data.table. Its colums are:

"word", "producerID", "producerLabel", "producerNrOfTimesHeard",  "perceiverID", "perceiverLabel" , "perceiverNrOfTimesHeard",
"accepted", "simulationNr", "valid"
That's a log of all interactions. Each row is an interaction happened during simulationNr (== condition), where "word" produced by "producerID" was perceived by "perceiverID" and accepted == TRUE or FALSE. Here "valid" will always be TRUE at simulation end, but it's used internally (preallocate mem). 















